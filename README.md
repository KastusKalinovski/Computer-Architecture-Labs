# Computer_Architecture_Labs

### Часть 1. ТЕХНОЛОГИЯ ММХ, SIMD
Для выполнения данной работы необходимо выполнить следующее: 

1.  изучить программную модель ММХ;

2.  изучить систему команд ММХ;

3.  обработать массивы из 8 элементов по следующему выражению (в зависимости от варианта):


F[i]=A[i] *(B[i]) +C[i] )-D[i] , i=1...8.


Используются следующие массивы:

A, B и С – 8 разрядные целые знаковые числа (_int8);

D – 16 разрядные целые знаковые числа (_int16).

Полученный результат отобразить на форме с использованием соответствующих элементов. При распаковке знаковых чисел совместно с командами распаковки использовать команды сравнения (сравнивать с нулём перед распаковкой).

 


### Часть 2. Производитель-потребитель.

Производитель-потребитель является распространенным шаблоном
проектирования с множеством вариантов реализации. Обычно, производиетль и
потребитель связываются потокобезопасной очередью задач, в которую пишет
один или несколько производителей и читает один или несколько потребителей. В
этой части необходимо разработать несколько реализаций потокобезопасной
очереди сообщений.

Задача. Написать код инстанциирующий ConsumerNum потребителей и
ProducerNum производителей. Связать их потокобезопасной очередью, хранящей
однобайтные элементы. Потребители инстанциируют локальный счетчик, после
чего начинают читать очередь и прибавлять вычитанные значения к локальному
счетчику. Каждый производитель записывает TaskNum единиц в очередь и
завершает свою работу. Когда все производители записали свои сообщения и
потребители опустошили очередь, потребители завершают свою работу и
возвращают получившиеся суммы. Необходимо засечь время работы
производителей и потребителей и проверить, что итоговая сумма результатов всех
потребителей равна ProducerNum / TaskNum. Протестировать для
ProducerNum={1, 2, 4}, ConsumerNum={1, 2, 4}, TaskNum=4*1024*1024.
Интерфейс очереди:

```cpp
class queue
{ public:
// Записывает элемент в очередь.
// Гсли очередь фиксированного размер и заполнена,
// поток повисает внутри функции пока не освободится место
void push(uint8_t val);
// Если очередь пуста, ждем 1 мс записи в очередь.
// Если очередь не пуста, помещает значение головы в val,
// удаляет голову и возвращает true.
// Если очередь по прежнему пуста, возвращаем false
bool pop(uint8_t& val);
};
```

Задачу необходимо решить для следующий вариантов реализации очереди:
1. Динамическая очередь с использованием std-контейнеров и std::mutex.
2. Очередь фиксированного размера QueueSize с использованием std::mutex и
std::condition_variable без busy wait. Протестировать для QueueSize={1, 4,
16}.
